package common

import (
	"encoding/binary"
	"math"
)

/*
	The structure of binary chunk.
	+-----------------------+ ---
	|	signature			|  |
	-------------------------  |
	|	version				|  |
	-------------------------  |
	|	format				|  |
	-------------------------  |
	|	endian				|  |
	-------------------------  |
	|	int size			|  |
	-------------------------  | Header
	|	sizet size			|  |
	-------------------------  |
	|	instruction size	|  |
	-------------------------  |
	|	lua Number size		|  |
	-------------------------  |
	|	flag				|  |
	+-----------------------+ ---
	|	Source				|  |
	-------------------------  |
	|	StartLine			|  |
	-------------------------  |
	|	EndLine				|  |
	-------------------------  |
	|	UpvalueCount		|  |
	-------------------------  |
	|	Numparams			|  | Function proto
	-------------------------  |
	|	IsVararg			|  |
	-------------------------  |
	|	MaxStackSize		|  |
	-------------------------  |
	|	Instructions		|  |
	-------------------------  |
	|	Constants			|  |
	-------------------------  |
	|	Protos				|  |
	+-----------------------+ ---

	Header
	signature:		Magic number of lua, 4 bytes size.
					Occupied by 'ESC','L','u','a' in ASCII. The value is "\033Lua" in golang string type.
	version:		The version of lua, 1 byte size.
					The value combined by major version and minor version only. For exmaple, "0x51" is the value of the 5.1.1 version.
	format:			The format number of chunk. The Lua offical format number is 0.
	endian:			Big endian is 0. Little endian is 1.
	int size:		The size of int type is 4 bytes.
	sizet size:		The size of size_t type is 8 bytes.
	instruction size:	The size of lua virtual machine instuction. The Value is 4 bytes.
	lua number size:	The size of lua number is 8 bytes.
	flat:			Float is 0. Integer is 1. Default value 0.

	Function proto
	Source:			The name of source code file. The value is combined by length+1 and string which is the file name.
					First char of the string could be '@','=stdin' or nothing. '@' means the chunk is generated by
					source code file. '=stdin' means the chunk is generated by standard input.
	StartLine:	The start line number of the function.
	EndLine:The end line number of the function.
	UpvalueCount:	The number of upvalues.
	Numparams:		The number of parameters.
	IsVararg:		Whether the amount of parameters is varialble.
	MaxStackSize:	The number of registers. This value is generated during compiling by Lua Virtual Machine.
					The registers is implemented by stack, so this field is also called 'max stack size'.
	Instructions:	The table of instructions. Each instruction occupy 4 bytes.The virtural machine instruction, which are compiled from the source instructions in function.
	Constants:		Store literals in lua, support types: nil, boolean, integer, number, short string, long string. The first byte of the constant
					is the tag of those type.
					tag				literal type
					0x00			nil
					0x01			boolean
					0x03			number
					0x13			integer
					0x04			short string
					0x14			long string
	Protos:			The array of sub function protos.
*/

/*
	The proto of the main function
*/
type FuncProto struct {
	Source       string
	StartLine    uint32
	EndLine      uint32
	UpvalueCount byte
	NumParams    byte
	IsVararg     byte
	MaxStackSize byte
	Instructions []uint32
	Constants    []interface{}
	Protos       []*FuncProto
}

/*
	Check whether is binary chunk by verifying the signature.
*/
func IsBinaryChunk(data []byte) bool {
	return len(data) > 4 &&
		string(data[:4]) == SIGNATURE
}

/*
	Load binary chunk, check header first and load the function proto.
*/
func LoadBinaryChunk(data []byte) *FuncProto {
	loader := &loader{data}
	loader.checkHeader()
	return loader.readProto("")
}

/*
	The structure of binary chunk.
*/
type binaryChunk struct {
	hdr      *header    // Header of the chunk
	mainFunc *FuncProto // The proto of the main function
}

/*
	Header of the chunk
*/
type header struct {
	signature       [4]byte
	version         byte
	format          byte
	endian          byte
	intSize         byte
	sizetSize       byte
	instructionSize byte
	luaNumberSize   byte
	flat            byte
}

const (
	SIGNATURE        = "\033Lua"
	VERSION          = 0x51
	FORMAT           = 0
	ENDIAN           = 1
	INT_SIZE         = 4
	SIZET_SIZE       = 8
	INSTRUCTION_SIZE = 4
	LUA_NUMBER_SIZE  = 8
	FLAT             = 0
)

const (
	TAG_NIL       = 0x00
	TAG_BOOLEAN   = 0x01
	TAG_NUMBER    = 0x03
	TAG_INTEGER   = 0x13
	TAG_SHORT_STR = 0x04
	TAG_LONG_STR  = 0x14
)

/*
	Upvalue is a variable in the enclosing function.
	The variable is used by the nesting function, and is called upvalue in the nesting function.
	There are three kinds of variables in lua, such as local variable, upvalue, global variable.
	Local variable is defined in a function.
	Upvalue is defined in a enclosing function, and used by a nesting function.
	Global variable is defined in _ENV.
*/
type Upvalue struct {
	Instack byte
	Idx     byte
}

/*
	Loader of binary chunk which is stored in a byte array.
*/
type loader struct {
	data []byte // store binary chunk
}

/*
	+-----------------------+ ---
	|	signature			|  |
	-------------------------  |
	|	version				|  |
	-------------------------  |
	|	format				|  |
	-------------------------  |
	|	endian				|  |
	-------------------------  |
	|	int size			|  |
	-------------------------  | Header
	|	sizet size			|  |
	-------------------------  |
	|	instruction size	|  |
	-------------------------  |
	|	lua Number size		|  |
	-------------------------  |
	|	flag				|  |
	+-----------------------+ ---
	Check the header of binary chunk, to ensure that the binary chunk is compatible with the lua of current version.
	This is very necessary before parse the binary chunk.
*/
func (self *loader) checkHeader() {
	if string(self.readBytes(4)) != SIGNATURE {
		panic("not a precompiled chunk!")
	} else if self.readByte() != VERSION {
		panic("version mismatch!")
	} else if self.readByte() != FORMAT {
		panic("format mismatch!")
	} else if self.readByte() != ENDIAN {
		panic("endianness mismatch!")
	} else if self.readByte() != INT_SIZE {
		panic("int size mismatch!")
	} else if self.readByte() != SIZET_SIZE {
		panic("size_t size mismatch!")
	} else if self.readByte() != INSTRUCTION_SIZE {
		panic("instruction size mismatch!")
	} else if self.readByte() != LUA_NUMBER_SIZE {
		panic("lua_Number size mismatch!")
	} else if self.readByte() != FLAT {
		panic("endianness mismatch!")
	}
}

/*
	+-----------------------+ ---
	|	Source				|  |
	-------------------------  |
	|	StartLine			|  |
	-------------------------  |
	|	EndLine				|  |
	-------------------------  |
	|	UpvalueCount		|  |
	-------------------------  |
	|	Numparams			|  | Function proto
	-------------------------  |
	|	IsVararg			|  |
	-------------------------  |
	|	MaxStackSize		|  |
	-------------------------  |
	|	Instructions		|  |
	-------------------------  |
	|	Constants			|  |
	-------------------------  |
	|	Protos				|  |
	Return function proto from binary chunk.
*/
func (self *loader) readProto(parentSource string) *FuncProto {
	source := self.readString()
	if source == "" {
		source = parentSource
	}
	return &FuncProto{
		Source:       source,
		StartLine:    self.readUint32(),
		EndLine:      self.readUint32(),
		UpvalueCount: self.readByte(),
		NumParams:    self.readByte(),
		IsVararg:     self.readByte(),
		MaxStackSize: self.readByte(),
		Instructions: self.readInstructions(),
		Constants:    self.readConstants(),
		Protos:       self.readProtos(source),
	}
}

/*
	Return 1 byte from data.
*/
func (self *loader) readByte() byte {
	b := self.data[0]
	self.data = self.data[1:]
	return b
}

/*
	Return n bytes from data.
*/
func (self *loader) readBytes(n uint) []byte {
	bytes := self.data[:n]
	self.data = self.data[n:]
	return bytes
}

/*
	Return a uint32 value from data.
*/
func (self *loader) readUint32() uint32 {
	i := binary.LittleEndian.Uint32(self.data)
	self.data = self.data[4:]
	return i
}

/*
	Return a uint64 value from data.
*/
func (self *loader) readUint64() uint64 {
	i := binary.LittleEndian.Uint64(self.data)
	self.data = self.data[8:]
	return i
}

/*
	Return a uint32 value from data.
*/
func (self *loader) readLuaInteger() int64 {
	return int64(self.readUint32())
}

/*
	Return a float64 value from data.
*/
func (self *loader) readLuaNumber() float64 {
	return math.Float64frombits(self.readUint64())
}

/*
	Return string from data.
*/
func (self *loader) readString() string {
	size := uint(self.readUint64())
	if size == 0 {
		return ""
	}
	bytes := self.readBytes(size - 1)
	self.readByte()      //Read \x00 out of string.
	return string(bytes) // todo
}

/*
	Return insturctions from data.
*/
func (self *loader) readInstructions() []uint32 {
	code := make([]uint32, self.readUint32())
	for i := range code {
		code[i] = self.readUint32()
	}
	return code
}

/*
	Return constants from data.
*/
func (self *loader) readConstants() []interface{} {
	constants := make([]interface{}, self.readUint32())
	for i := range constants {
		constants[i] = self.readConstant()
	}
	return constants
}

/*
	Return a constant byte from data.
*/
func (self *loader) readConstant() interface{} {
	switch self.readByte() {
	case TAG_NIL:
		return nil
	case TAG_BOOLEAN:
		return self.readByte() != 0
	case TAG_INTEGER:
		return self.readLuaInteger()
	case TAG_NUMBER:
		return self.readLuaNumber()
	case TAG_SHORT_STR, TAG_LONG_STR:
		return self.readString()
	default:
		panic("corrupted!") // todo
	}
}

/*
	Return funtion protos from data.
*/
func (self *loader) readProtos(parentSource string) []*FuncProto {
	protos := make([]*FuncProto, self.readUint32())
	for i := range protos {
		protos[i] = self.readProto(parentSource)
	}
	return protos
}
